# 第 9 章 数据库

## 9.1 服务器中的数据库

redis 将所有数据库都保存在服务器状态的`db`数组里。`db`属性的定义位于 redis-7.2.4/src/server.h 的 1548 行处。

```c
struct redisServer {
    redisDb *db;
}
```

每一个`redisDb`结构均代表一个数据库。

还有一个`dbnum`属性：

```c
struct redisServer {
    int dbnum;            /* Total number of configured DBs */
}
```

在初始化服务器时，程序会根据`dbnum`属性的值来决定应该创建多少个数据库。

而`dbnum`属性的值由配置文件中`database`选项决定，该选项的值默认是 16。



## 9.2 切换数据库

每个 Redis 客户端都有自己的目标数据库，可以通过`SELECT`命令来切换目标数据库。

目标数据库被记录在每个客户端状态的`db`属性上。`db`属性的定义位于 redis-7.2.4/src/server.h 的 1158 行处。

```c
typedef struct client {
    redisDb *db;
}
```



## 9.3 数据库键空间

`redisDb`结构中的`dict`属性保存着数据库中的所有键值对。`dict`属性的定义位于 redis-7.2.4/src/server.h 的 968 行处。

```c
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
}
```

数据库键空间是一个字典，所有针对数据库的操作，都是通过对键空间字典进行操作来实现的。



## 9.4 设置键的生存时间或过期时间

可以通过`EXPIRE`或`PEXPIRE`命令，以秒或者毫秒精度为数据库中的某个键设置生存时间。

可以通过`EXPIREAT`或`PEXPIREAT`命令，以秒或者毫秒精度为数据库中的某个键设置过期时间。过期时间是一个 UNIX 时间戳。

可以通过`TTL`或`PTTL`命令返回这个键的剩余生存时间。

1. **过期时间的设置**

   可以通过`EXPIRE`、`PEXPIRE`、`EXPIREAT`、`PEXPIREAT`四个命令设置键的过期时间。但是`EXPIRE`、`PEXPIRE`、`EXPIREAT`这三个命令最终都会被转换成`PEXPIREAT`命令执行。

2. **过期时间的保存**

   `redisDb`结构中的`expires`字典保存了数据库中所有键的过期时间。位于 redis-7.2.4/src/server.h 的 969 行处：

   ```c
   typedef struct redisDb {
       dict *expires;              /* Timeout of keys with a timeout set */
   }
   ```

3. **过期时间的移除**

   可以通过`PERSIST`命令移除一个键的过期时间。

   `PERSIST`命令是`PEXPIREAT`命令的反向操作，移除过期字典中给定键的键值对关联。

4. **计算并返回剩余生存时间**

   `TTL`命令以秒为单位返回键的剩余生存时间，`PTTL`命令以毫秒为单位返回键的剩余生存时间。

   这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。

5. **过期键的判定**

   过期键的判定过程：

   1. 检查给定键是否存在于过期字典，如果存在，取得键的过期时间。
   2. 检查当前 UNIX 时间戳是否大于键的过期时间，如果是，则键已过期。



## 9.5 过期键删除策略

过期键删除策略有三种：定时删除、惰性删除、定期删除。

1. **定时删除**

   在设置键的过期时间的同时，设置一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

   定时删除对内存最友好，对 CPU 时间最不友好。

2. **惰性删除**

   每次从键空间中获取键时，都检查取得的键是否过期，若过期，则删除键。

   对 CPU 时间最友好，对内存最不友好。

3. **定期删除**

   程序每隔一段时间对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及检查多少数据库由算法决定。

   两种策略的整合和折中，但难点在于确定删除操作执行的时长和频率。



## 9.6 Redis 的过期键删除策略

Redis 服务器使用惰性删除和定期删除两种策略。



### 9.6.1 惰性删除策略的实现

Redis 的惰性删除策略由 `expireIfNeeded` 函数实现，可以在 redis-7.2.4/src/db.c 文件的 1775 行处找到 `expireIfNeeded` 函数。

所有读写数据库的 Redis 命令在执行前都会调用 `expireIfNeeded` 函数对输入键进行检查。



### 9.6.2 定期删除策略的实现

没有在 redis-7.2.4/src 目录里找到 redis.c 源文件。但是在 redis-7.2.4/src/expire.c 文件的 142 行处找到了 `activeExpireCycle` 函数。在 redis-7.2.4/src/server.c 文件的 1260 行处找到 `serverCron` 函数。

Redis 的定期删除策略由 `activeExpireCycle` 函数实现，

每当周期函数 `serverCron` 执行时，`activeExpireCycle` 函数通过 `databasesCron` 函数被间接调用。

`activeExpireCycle` 函数的具体实现细节略。



## 9.8 数据库通知

数据库通知是 2.8 版本新增加的功能，可以分为键空间通知或键事件通知。

* 键空间通知：查看某个键执行了什么命令。
* 键事件通知：查看某个命令被什么键执行了。

两个通知对应的命令有点长，略。

可以在 redis-7.2.4/redis.conf 文件里的 1900 多行处找到 `notify-keyspace-events` 选项，该选项决定了服务器允许发送通知的类型。



### 9.8.1 发送通知

发送通知的功能由 `notifyKeyspaceEvent` 函数来实现，可以在 redis-7.2.4/src/notify.c 文件的 104 行处找到该函数。

每当一个 Redis 命令需要发送数据库通知的时候，该命令的实现函数就会调用 `notifyKeyspaceEvent` 函数。

例如 redis-7.2.4/src/t_set.c 文件的 605行处的 `saddCommand` 函数，在 624 行就调用了 `notifyKeyspaceEvent` 函数。



<br>

# 第 10 章 RDB 持久化

为了解决当服务器进程退出，服务器中的数据库状态会消失不见这一问题，Redis 提供了 RDB 持久化功能，将 Redis 在内存当中的数据库状态保存到磁盘里。

RDB 持久化功能，既可以手动执行，也可以定期执行。生成的 RDB 文件是一个经过压缩的二进制文件。



## 10.1 RDB 文件的创建和载入

可以通过命令`save`和`bgsave`来创建 RDB 文件。

`save`命令：使用`save`命令后，服务器一直处于阻塞状态。

`bgsave`命令：创建一个子进程来执行 RDB 文件的创建，不会阻塞父进程。

创建 RDB 文件的工作由函数`rdbSave`执行，位于 redis-7.2.4/src/rdb.c 文件的 1516 行处。

载入 RDB 文件的工作由函数`rdbLoad`执行，位于 redis-7.2.4/src/rdb.c 文件的 3376 行处。

注意：如果开启了 AOF 持久化功能，那么会优先使用 AOF 文件。



## 10.2 自动间隔性保存

1. **save 选项**

   在 redis-7.2.4/redis.conf，420 多行处的`save`选项，通过配置该选项，可以让服务器每隔一段时间自动执行`bgsave`命令。如果用户没有在 主动设置 `save` 选项，那么服务器会为 `save` 选项设置默认条件。

   `save`选项会被载入到`redisServer`结构的`saveparams`数组里，位于 redis-7.2.4/src/server.h 中的 1791 行处：

   ```c
   struct redisServer {
   	struct saveparam *saveparams;   /* Save points array for RDB */
   }
   struct saveparam {
       time_t seconds;
       int changes;
   };
   ```

2. **dirty 计数器和 lastsave 属性**

   `dirty`属性：redis-7.2.4/src/server.h 1787 行处。该属性记录距离上一次成功执行`save`命令或`bgsave`命令之后，服务器对数据库状态进行了多少次修改。

   ```c
   struct redisServer {
   	long long dirty;         /* Changes to DB from the last save */
   }
   ```

   `lastsave`属性：redis-7.2.4/src/server.h 1798 行处。unix  时间戳，记录服务器上一次成功执行 `save` 命令或 `bgsave` 命令的时间。

   ```c
   struct redisServer {
       time_t lastsave;         /* Unix time of last successful save */
   }
   ```

3. **检查保存条件是否满足**

   Redis 的服务器周期性操作函数`serverCron`，其一项工作就是检查 `save` 选项所设置的保存条件是否满足，如果满足的话，就执行 `bgsave` 命令，也就是 `rdbSaveBackground` 函数（1413 行处）。当然，`dirty` 会被重置为 0，同时更新 `lastsave ` 属性。



## 10.3 RDB 文件的结构

略

<br>

# 第 11 章 AOF 持久化

AOF（ Append Only File） 持久化：通过保存 Redis 服务器所执行的**写命令**来记录数据库状态。

与 RDB 文件不同，写入 AOF 的所有命令都是以 Redis 的命令请求格式保存的，即纯文本格式，因此 AOF 文件的内容可以直接打开查看。同样，在服务器启动时，可以通过载入和执行 AOF 文件中保存的命令来还原数据库状态，相关信息可以在日志中查看。



## 11.1 AOF 持久化的实现

AOF 持久化的实现可以分为三步：命令追加、文件写入、文件同步。

1. **命令追加**

   当 AOF 持久化功能打开时，服务器在每执行完一个命令之后，都会以协议格式将被执行的命令追加到服务器状态的 `aof_buf` 缓冲区的末尾。

   `aof_buf`属性位置：redis-7.2.4/src/server.h 的 1763 行处：

   ```c
   struct redisServer {
       sds aof_buf;      /* AOF buffer, written before entering the event loop */
   }
   ```

2. **AOF 文件的写入和同步**

   因为现代操作系统为了提高效率，对于数据的写入，可分为**写入**和**同步**：

   * 写入：将数据写入到一块内存缓冲区。
   * 同步：将内存缓冲区中的数据写入到磁盘里。

   为此，系统也专门提供了两个函数。

   因此，对于`aof_buf` 缓冲区当中的数据，在将其写入 AOF 文件的时候，还需要考虑同步的时机。是应该写入的时候立刻同步？还是不同步？还是每隔一定时间自动同步？也就是三种同步策略：

   * AOF_FSYNC_NO：对应值 0，不同步。同步时机交由操作系统。
   * AOF_FSYNC_ALWAYS：每次写入都同步。
   * AOF_FSYNC_EVERYSEC：每 1 秒钟同步一次（默认）。

   以上常量的位置位于 redis-7.2.4/src/server.h 的 526-528 行处。

   AOF 文件的写入和同步工作由函数`flushAppendOnlyFile`处理，该函数的定义位于 redis-7.2.4/src/server.h 文件的 2853 行处，实现位于 redis-7.2.4/src/aof.c 文件的 1064 行处。



## 11.2 AOF 文件的载入和数据还原

主要步骤：

1. 创建一个不带网络连接的**伪客户端**。
2. 从 AOF 文件 中分析并读取出一条写命令。
3. 使用伪客户端执行被读出的写命令。
4. 一直执行步骤 2 和 3，直到 AOF 文件里所有写命令均被处理完毕为止。



## 11.3 AOF 重写

由于 AOF 持久化会带来文件体积膨胀的问题，因此 Redis 提供了 AOF 文件重写的功能，重写后生成的新的 AOF 文件不会包含任何浪费空间的冗余命令。

1. **AOF 文件重写的实现**

   AOF 文件重写，虽然叫重写，但是**不包含对旧 AOF 文件的任何操作**，而是通过读取服务器当前状态来实现的。重写的原理是：先从数据库中读取键现在的值，然后用**一条命令**去记录键值对，代替之前记录这个键值对的多条命令。

   AOF 文件重写在处理列表、哈希表、集合、有序集合四种会带有多个元素的键时，可能会出现输入缓冲区溢出的情况。因此，在这之前会先检查键所包含的元素数量是否超过了某一个常量，如果超过了，则会用多条命令来记录。

   该常量在 redis-7.2.4 中叫`AOF_REWRITE_ITEMS_PER_CMD` ，定义位于 redis-7.2.4/src/server.h 文件的 125 行处：

   ```c
   #define AOF_REWRITE_ITEMS_PER_CMD 64
   ```

   这四种键的重写函数的实现则位于 redis-7.2.4/src/aof.c 文件，函数名分别叫做：

   ```c
   int rewriteListObject(...){}		// 1794 行处
   int rewriteSetObject(...) {}		// 1836 行处
   int rewriteSortedSetObject(...) {}	// 1868 行处
   int rewriteHashObject() {} 			// 1974 行处
   ```

   并且在内部函数体均有下面这条比较语句：

   ```c
   int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;
   ```

2. **AOF 后台重写**

   AOF 重写程序被放到了**子进程**里执行，但是需要考虑一个问题：如果子进程在重写期间，父进程又接受处理了新的命令请求，新的命令请求对现有的数据库状态又进行了新的修改，那么就会导致重写后的 AOF 文件和当前的数据库状态不一致。

   因此，Redis 设置了一个 **AOF 重写缓冲区**来解决这一问题。

   AOF 后台重写的大致流程：

   1. 父进程创建一个子进程来进行 AOF 文件重写。
   2. 父进程期间又接受到了新的命令请求的话，将新的命令请求放入到 **AOF 重写缓冲区**当中。
   3. 子进程完成了 AOF 文件重写，向父进程发送处理完成的信号。
   4. 父进程接受到信号后，调用**信号处理函数**，该函数会将 **AOF 重写缓冲区**当中的内容**追加**到新的 AOF 文件里，并对文件名进行重命名，覆盖旧的 AOF 文件。只有在这期间，**父进程才会处于阻塞状态**。
   5. **信号处理函数**执行完毕后，父进程继续正常工作。

   这也是 `BGREWRITEAOF` 命令的实现原理。

   :::tip

   在子进程重写 AOF 文件期间，如果父进程接受到的新的命令请求包含了冗余命令呢？那么会不会导致 AOF 文件里又出现了新的冗余命令呢？

   :::

<br>

# 第 12 章 事件

Redis 服务器就是一个事件驱动程序，其处理的事件包括以下两类：

* 文件事件：Redis 服务器通过**套接字**与客户端进行连接，文件事件是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件来完成一系列网络通信操作。
* 时间事件：Redis 服务器中的一些操作需要在给定的时间点执行，时间事件就是服务器对这类定时操作的抽象。



## 12.1 文件事件

略。

<br>

# 第 13 章 客户端

Redis 服务器是典型的**一对多**服务器程序，通过 **IO 多路复用技术**实现的文件事件处理器，Redis 服务器使用**单线程单进程**的方式来处理命令请求，并与多个客户端进行网络通信。

Redis 服务器为每个与之连接的客户端都建立了一个 `redisClient` 结构（客户端状态）。在 redis-7.2.4/src/server.h 文件的 1153 行处找到了 `client` 结构的定义，同样在该文件的 1534 行处找到了 `redisServer` 结构（服务器状态）的定义。

在 `redisServer` 结构中，维护了一个 `clients` 属性的链表：

```c
list *clients;              /* List of active clients */
```

该属性保存了所有与服务器连接的客户端的状态结构。

在 redis-7.2.4/README.md 文件的 295 行处有对 `client` 结构的说明。



## 13.1 客户端属性

客户端状态包含的属性可以分为**通用属性**和**特定属性**。

1. **套接字描述符**

   `fd` 属性：保存客户端正在使用的套接字描述符。可以通过`CLIENT LIST`命令的`fd`域查看。

   `fd` 属性的值

   - 伪客户端：1
   - 普通客户端：大于 -1 的整数

   位置：redis-7.2.4/src/connection.h 文件的 `connection` 结构当中，在 114 行处。

2. **名字**

   `name` 属性：保存了客户端的名字。可以通过`CLIENT LIST`命令的`name`域查看。

   `name` 属性的值：默认空，可以通过`CLIENT SETNAME`命令设置客户端的名字。

   位置：redis-7.2.4/src/server.h 的 1159 行处。

3. **标志**

   `flags` 属性：保存客户端的角色以及目前所处的状态。

   `flags` 属性的值：由一个或多个标志的二进制组成。

   位置：redis-7.2.4/src/server.h 中的 334 行处可以找到所有的标志定义。

4. **输入缓冲区**

   `querybuf` 属性：保存客户端发送的命令请求的协议格式。

   位置：redis-7.2.4/src/server.h 中的 1162 行处。

   注意：输入缓冲区的大小不能超过 1 GB。

5. **命令与命令参数**

   `argc` 属性：是一个数组，保存命令请求的命令参数。

   `argv` 属性：保存参数个数，即数组的长度

   位置：redis-7.2.4/src/server.h 中的 1165、1166 行处。

   ```c
   typedef struct client {
       int argc;               /* Num of arguments of current command. */
       robj **argv;            /* Arguments of current command. */
   }
   ```

6. **命令的实现函数**

   `cmd` 属性：保存命令的实现函数。

   `cmd` 属性的值：是一个**redisCommond 结构**的指针对象。

   位置：redis-7.2.4/src/server.h 中的 1171 行处。

   ```c
   typedef struct client {
       struct redisCommand *cmd, *lastcmd;  /* Last command executed. */
   }
   ```

7. **输出缓冲区**

   1. 固定大小的输出缓冲区

      `buf` 属性：保存命令的简单回复结果。

      位置：redis-7.2.4/src/server.h 中的 1272 行处。

      ```c
      typedef struct client {
          char *buf;
      }
      ```

      固定大小的输出缓冲区的大小由常量`PROTO_REPLY_CHUNK_BYTES`决定。其位于 redis-7.2.4/src/server.h 的 177 行处：

      ```c
      #define PROTO_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */
      ```

   2. 可变大小的输出缓冲区

      `reply` 属性：保存命令的较长回复结果。

      位置：redis-7.2.4/src/server.h 中的 1181 行处。

      ```c
      typedef struct client {
          list *reply;            /* List of reply objects to send to the client. */
      }
      ```

      注意：可变大小的输出缓冲区是存在限制的，与软性限制、硬性限制相关。

8. **身份验证**

   `authenticated` 属性：记录客户端是否通过了身份验证。

   `authenticated` 属性的值：未通过 0，通过 1。

   位置：redis-7.2.4/src/server.h 中的 1192 行处。

   ```c
   typedef struct client {
       int authenticated;      /* Needed when the default user requires auth. */
   }
   ```

   当属性值为 0 时，除了`auth`命令之外，客户端发送的所有其他命令都会被服务器拒绝执行。

   注意：**该属性仅在服务器启用了身份验证功能时使用**。

9. **时间**

   `ctime`属性：记录了创建客户端的时间，可以通过`CLIENT LIST`命令的`age`域查看。

   `lastinteraction`：记录了客户端与服务器最后一次进行互动的时间。

   `obuf_soft_limit_reached_time`：输出缓冲区第一次到达软性限制的时间。



## 13.2 客户端的创建与关闭

因为客户端的类型可以分为**普通客户端**以及**伪客户端**，因此，针对不同的客户端，服务器有不同的创建和关闭的方式。

1. 普通客户端

   * 创建

     对于普通客户端，服务器会通过**连接事件处理器**，为客户端创建相应的**客户端状态**，并将这个客户端状态添加到服务器状态结构的 `clients` 链表的末尾。

     ```c
     typedef struct redisServer {
     	list *clients;              /* List of active clients */
     }
     ```

   * 关闭

     普通客户端可能会因为多种原因而被关闭，例如以下这些：

     1. 客户端进程退出或者被杀死。
     2. 客户端发送了带有不符合协议格式的命令请求。
     3. 客户端成为了 `CLIENT KILL` 命令的目标。
     4. 客户端空转时间超过了 `timeout` 配置选项的值时（存在特殊情况）。
     5. 客户端发送的命令请求超出了输入缓冲区的限制大小（默认 1GB）
     6. 服务器发送给客户端的命令回复超出了输出缓冲区的限制大小。
     7. ......

     关于第 6 点：虽然对于可变大小的输出缓冲区，理论上可以保存任意长的命令回复，但是服务器依然为其执行了相应的限制操作：

     * 硬性限制：如果输出缓冲区的大小超过了硬性限制，服务器立即关闭客户端。
     * 软性限制：如果输出缓冲区的大小超过了软性限制（未超过硬性限制），服务器会将超出软性限制的起始时间记录到客户端状态结构的 `obuf_soft_limit_reached_time` 属性上，并继续监视，如果在服务器规定的时间内一直超出了软性限制，那么服务器就会关闭客户端。

2. 伪客户端

   * Lua 脚本的伪客户端

     Lua 脚本的伪客户端会在服务器初始化的时候创建，并存在于服务器的整个生命周期。

   * AOF 文件的伪客户端

     服务器在载入 AOF 文件的时候，会创建用于执行 AOF 文件包含的 Redis 命令的伪客户端，载入完毕之后关闭该客户端。

<br>

# 第 14 章 服务器

Redis 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据， 并通过资源管理来维持服务器自身的运转。



## 14.1 命令请求的执行过程

可以分为以下几步：

1. 客户端向服务器发送命令请求。

   当用户在客户端键入一个命令请求时，客户端会将其转换成**协议格式**，通过连接到服务器的套接字，将转换成协议格式的命名请求发送给服务器。

2. 服务器接受并处理命令请求。

   服务器会调用**命令请求处理器**来执行接下来的操作。具体步骤如下：

   1. 从套接字中读取协议格式的命令请求，将其保存到客户端状态的**输入缓冲区**中，即`querybuf`属性。

   2. 分析并提取命令请求中包含的命令参数以及命令个数，将它们分别保存到客户端状态的`argv`和`argc`属性中。

   3. 调用**命令执行器**，执行客户端指定的命令。命令执行器的具体步骤如下：

      1. 查找命令实现。

         根据客户端状态的 argv[0] 参数，在**命令表**中查找参数所指定的命令，并将找到的命令保存到客户端状态的 `cmd` 属性里。

      2. 执行预备操作。

         在真正执行命令之前，程序会执行一些预备操作，以确保命令可以正确、顺利地执行。

      3. 调用命令的实现函数。

      4. 执行后续工作。

3. 服务器将命令回复发送给客户端。

4. 客户端接收并打印命令回复。



## 14.2 serverCron 函数

`serverCron` 函数默认每隔 **100 毫秒**执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。该函数执行的操作有以下这些：

1. **更新服务器时间缓存**

   Redis 服务器中有不少功能需要获取系统的当前时间，这些功能当中有些对精确度要求不高，有些要求高。为了减少系统调用的次数，对于**精确度要求不高的功能**，Redis 使用服务器状态中的 `unixtime` 属性和 `mstime` 属性，来作为当前时间的缓存。

   * `unixtime` 属性：保存了秒级精度的系统当前 UNIX 时间戳。

   * `mstime` 属性：保存了毫秒级精度的系统当前 UNIX 时间戳。

2. **更新 LRU 时钟**

   服务器状态中的`lruclock`属性也是属于时间缓存的一种，Redis 通过 `unixtime` 属性和 `mstime` 属性来计算`lruclock`属性。该属性默认每隔 10 秒更新一次，用于计算键的空转（idle）时长，就是 Redis 对象的 `lru` 属性。

   该属性可以通过 `INFO server`命令的`lru_clock`域查看。

3. **更新服务器每秒执行命令次数**

   没有在 redis-7.2.4 源码中找到书中说的`trackOperationsPerSecond`函数。

4. **更新服务器内存峰值记录**

   服务器状态中的`size_t stat_peak_memory`属性记录了服务器的内存峰值大小。

   在 redis-7.2.4/src/server.h 的1660 行处：

   ```c
   struct redisServer {
   	size_t stat_peak_memory;        /* Max used memory record */
   }
   ```

   serverCron 函数每次执行时，程序都会查看服务器当前使用的内存数量，并与该属性进行比较，若大于则更新。

   `INFO memory`命令的 `used_memory_peak`和`used_memory_peak_human`分别以两种格式记录了服务器内存峰值。

5. **处理 SIGTERM 信号**

6. **管理客户端资源**

7. **管理数据库资源**

8. **执行被延迟的 BGREWRITEAOF**

9. **检查持久化操作的运行状态**

10. **将 AOF 缓冲区中的内容写入 AOF 文件**

11. **关闭异步客户端**

12. **增加 cronloops 计数器的值**



## 14.3 初始化服务器



<br>

# 第 15 章 复制

可以通过`SLAVEOF`命令或配置`slaveof`选项让一个服务器去复制另一个服务器。

`slaveof`选项？



## 15.1 旧版复制功能的实现

Redis 的复制功能可以分为**同步**和**命令传播**两个操作。

主从服务器的**同步**过程：

1. 从服务器向主服务器发送`sync`命令。
2. 主服务器收到`sync`命令后，执行`BGSAVE`命令生成 RDB 文件，并创建一个缓冲区记录从现在开始执行的所有写命令。
3. 当`BGSAVE`命令执行完毕之后，主服务器将生成的 RDB 文件发送给从服务器，从服务器接受并载入 RDB 文件。
4. 主服务器将缓冲区中的数据发送给从服务器，从服务器执行写命令，同步完成。

当主从服务器状态又不一致的时候，主服务器需要对从服务器执行**命令传播**操作：主服务器会将造成主从服务器不一致的写命令发送给从服务器执行。



## 15.2 旧版复制功能的缺陷

对于初次复制来说，旧版复制功能可以很好地完成任务，但对于断线后重复制来说，旧版的复制功能效率非常低。

因为当断线后重新连接上主服务器时，从服务器会向主服务器发送`sync`命令要求执行同步操作，主服务器会将所有的数据写入到 RDB 文件发送给从服务器，而这个 RDB 文件中包含的大部分数据对从服务器来说都是不必要的。

并且，`sync`命令是一个非常耗费资源的操作：

1. 执行`BGSAVE`命令生成 RDB 文件，会耗费主服务器大量的 CPU、内存和磁盘 I/O 资源。
2. 将  RDB 文件发送给从服务器会耗费主服务器大量的网络资源（带宽和流量），并会对主服务器相应的命令请求的时间产生影响。
3. 从服务器在载入 RDB 文件期间处于阻塞状态，无法处理命令请求。



## 15.3 新版复制功能的实现

Redis 从 2.8 版本开始，使用`PSYNC`命令代替`SYNC`命令来执行复制时的同步操作。

`PSYNC`命令具有**完整重同步**和**部分重同步**两种模式。

完整重同步：用于处理初次复制的情况。其执行步骤与`SYNC`命令基本一样。

部分重同步：用于处理断线后重复制的情况。当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器接收并执行。



## 15.4 部分重同步的实现

部分重同步的实现包括了以下三个部分：

1. 主/从服务器的**复制偏移量**。
2. 主服务器的**复制积压缓冲区**。
3. 服务器的**运行 ID**。

重连后的同步过程如下：

1. 当从服务器重现连接主服务器时，从服务器向主服务器发送`PSYNC`命令并附上**偏移量**、之前连接的主服务器的**运行 ID**。

2. 主服务器判断这个 ID 是否是自己的运行 ID：

   1. 不是：执行完整重同步操作。

   2. 是：尝试执行部分重同步操作。

      主服务器判断这个偏移量之后的数据是否存在于**复制积压缓冲区**里：

      1. 是：主服务器将对从服务器执行部分重同步操作。
      2. 不是：主服务器将对从服务器执行完整重同步操作。



## 15.5 PSYNC 命令的实现

`PSYNC` 命令的两种调用方法：

1. 如果从服务器以前没有复制过任何主服务器，或者之前执行过`SLAVEOF NO ONE`命令，那么从服务器会向主服务器发送`PSYNC ? -1`命令，向主服务器主动请求完整重同步。

2. 相反，则从服务器会向主服务器发送`PSYNC <运行ID> <偏移量>`命令。

   之后，主服务器会根据具体情况返回三种回复中的一种：

   1. `+FULLRESYNC <运行ID> <偏移量>`：主服务器将与从服务器执行完整重同步操作。

      从服务器保存运行 ID，并记录初始偏移量。

   2. `+CONTINUE`：主服务器将与从服务器执行部分重同步操作。

      从服务器等待数据发送即可。

   3. `-ERR`：主服务器的版本低于 Redis 2.8，无法识别`PSYNC`命令。

      从服务器向主服务器发送`SYNC`命令，与主服务器执行完整同步操作。



## 15.6 复制的实现

通过`SLAVEOF`命令可以让一个从服务器去复制一个主服务器：`SLAVEOF 主机名 端口`。

具体复制步骤：

1. **设置主服务器的地址和端口**。

   从服务器将`SLAVEOF`命令所携带的主服务器 IP 地址以及端口保存到服务器状态的`masterhost`属性和`masterport`属性里面。

   两个属性位于 redis-7.2.4/src/server.h 的 1874 行和 1875 行处：

   ```c
   struct redisServer {
   	char *masterhost;               /* Hostname of master */
   	int masterport;                 /* Port of master */
   }
   ```

   `SLAVEOF`命令是一个异步命令，在完成顺序的设置工作之后，从服务器向客户端返回`OK`后正式开始执行复制工作。

2. **建立套接字连接**。

   从服务器会创建连向主服务器的套接字连接，如果成功连接到主服务器，那么从服务器会为这个套接字关联一个专门用于复制工作的文件事件处理器，该处理器负责执行后续的复制工作，例如接收 RDB 文件、接收传播命令等。

   主服务器在接收从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，此时，从服务器就相当于是主服务器的一个客户端。即**从服务器同时具备服务器和客户端两个身份**。

3. **发送 PING 命令**。

   在从服务器成为主服务器的客户端之后，从服务器会向主服务器发送一个 PING 命令。

   PING 命令的作用：

   - 检查套接字读写状态是否正常。
   - 检查主服务器能否正常处理命令请求。

   主服务器在收到 PING 命令的回复：

   - 主服务器发送了一个命令回复，但是从服务器无法在规定时间内接收：

     说明网络状态不佳。从服务器会断开并重新创建连向主服务器的套接字。

   - 主服务器返回了一个错误：

     说明主服务器繁忙，暂时没办法处理命令请求。从服务器会断开并重新创建连向主服务器的套接字。

   - 主服务器返回了 PONG 回复：说明一切正常。

4. **身份验证**。

   当从服务器收到 PONG 回复之后，会决定是否进行身份验证：

   - 如果从服务器设置了`masterauth`选项，那么进行身份验证，命令是`AUTH xxx`。
   - 如果从服务器没有设置`masterauth`选项，那么不进行身份验证。

   `masterauth`选项位于 redis-7.2.4/redis.conf 的 540 行处。

   身份验证的情况：

   - 主服务器没有设置`requirepass`选项，从服务器没有设置`masterauth`选项。

     复制工作继续。

   - 从服务器`AUTH`命令发送的密码与主服务器`requirepass`选项设置的密码相同。

     复制工作继续。反之，从服务器返回一个 invalid password 错误。

   - 主服务器设置了`requirepass`选项，从服务器没有设置`masterauth`选项。

     从服务器返回一个 NOAUTH 错误。反过来：

     主服务器没有设置`requirepass`选项，从服务器设置了`masterauth`选项。

     从服务器返回一个 no password is set 错误。

   所有身份验证的错误情况都会使得从服务器重新执行复制操作。

5. **发送端口消息**。

   在身份验证步骤之后，从服务器将执行命令`REPLCONF listening-port <端口号>`，向主服务器发送从服务器的监听端口号。

   主服务器在接收命令之后，会将这个端口号保存到从服务器所对应的客户端状态的`slave_listening_port`属性上。

   该属性位于redis-7.2.4/src/server.h 的1210 行处：

   ```c
   typedef struct client {
   	int slave_listening_port; /* As configured with: REPLCONF listening-port */
   }
   ```

   在主服务器上可以通过`INFO replication`命令打印处所属从服务器来查看该属性（记录在 port 域上）。

6. **同步**。

   从服务器向主服务器发送`[PSYNC]`命令，执行同步操作。

   注意：在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端。因为只有这样，才能保存主服务器可以通过写命令来改变从服务器的数据库的状态。

7. **命令传播**。

   完成同步之后，进入命令传播阶段。



## 15.7 心跳检测

在命令传播阶段，从服务器默认以每秒一次的频率向主服务器发送命令：`REPLCONF ACK <复制偏移量> `。

该命令的三个作用：

1. **检测主从服务器的网络连接状态**。

   可以通过`INFO replication`命令在列出的从服务器列表的 lag 一栏，看到从服务器最后一次向主服务器发送`REPLCONF ACK`命令距离现在过了多少秒。

   如果 lag 值超过了 1 秒，说明主从服务器之间的连接出现了故障。

2. **辅助实现`min-slaves`选项**。

   Redis 的`min-slaves-to-write`和`min-slaves-max-lag`两个选项可以防止主服务器在不安全的情况下执行写命令。

   ```c
   # min-slaves-to-write 3
   # min-slaves-max-lag 10
   ```

   在超出三个从服务器的延迟（lag）值都大于或等于 10 秒时，主服务器拒绝执行写命令。

   :::tip

   redis-7.2.4 里应该叫`min-replicas`选项。

   :::

3. **检测命令丢失**。

   当因为网络故障导致主服务器传播给从服务器的命令在半路丢失，那么当从服务器发送`REPLCONF ACK`命令时，主服务器就会发现复制偏移量不对，那么主服务器就根据从服务器提交的数据偏移量，在复制积压缓冲区里找到从服务器丢失的数据，重新发送给从服务器。

   以上就是 Redis 处理命令丢失的操作，或者说在 2.8 版本之后的操作。该操作与部分重同步的原理非常相似，区别在于一个是没有断线，一个是断线后重连。

   注意：在 2.8 版本以前没有处理手段。



# 第 17 章 集群

## 17.1 节点

一个集群由 1 个或多个节点组成，而一个节点就是一个运行在集群模式下的 Redis 服务器。

在刚开始的时候，每个节点都处于一个只包含自己的集群当中。如果想要：

* 将其他节点连接到当前节点所在的集群当中，可以使用命令：`CLUSTER MEET`。

* 查看当前节点所在的集群当中所有节点信息（包括自己），可以使用命令：`CLUSTER NODES`。



### 17.1.1 启动节点

需要在配置文件 redis.conf 中设置`custer-enabled`选项为 yes 来开启服务器的集群模式，这样 Redis 服务器就会成为一个节点。

节点会继续使用单机模式下的 Redis 服务器所使用的组件。



### 17.1.2 集群数据结构

当一个 Redis 服务器成为节点知乎，它就会使用一些在集群模式才会用到的数据。



